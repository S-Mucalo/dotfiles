*  Bootstrapping package and use-package

#+begin_src emacs-lisp :tangle no
  (defun debug-on-load-obsolete (filename)
    (when (equal (car (last (split-string filename "[/\\]") 2))
                 "obsolete")
      (debug)))
  (add-to-list 'after-load-functions #'debug-on-load-obsolete)

#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'package)

  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/"))

  (package-initialize)

  ;; Bootstrap `use-package'
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (use-package benchmark-init
    :ensure t
    :config
    ;; To disable collection of benchmark data after init is done.
    (add-hook 'after-init-hook 'benchmark-init/deactivate))

    (setq custom-file "~/.emacs.d/custom.el")
    (load custom-file 'noerror)


#+end_src

* Global settings
#+begin_src emacs-lisp :tangle yes
  (setq inhibit-startup-screen t)         ; Stop the splash screen
  (setq mouse-yank-at-point t)            ; When copying with the mouse, paste at point
  (setq ispell-list-command "--list")     ; Required for aspell backend
  (setq ispell-extra-args '("--sug-mode=fast")) ;; --sug-mode=fast,normal
  (setq ispell-local-dictionary "en_GB")
  (setq global-visual-line-mode t)        ; Move to the next row even if it's wrapped
  (setq column-number-mode t)             ; Display column position in modeline
  (setq backup-directory-alist '((".*" . "~/.emacs.d/backups")))
  (setq delete-old-versions t)            ; Delete old backups
  (setq kept-new-versions 6)
  (setq kept-old-versions 2)
  (setq version-control t)                ; Control version numbers for old files
  (setq mouse-autoselect-window t)        ; Move window focus with mouse move
  (setq focus-follows-mouse t)
  (setq show-paren-delay 0)               ; Show parens immediately
  (setq save-interprogram-paste-before-kill t) ; Save clipboard strings into killring before replacing them
  (setq select-enable-clipboard t)             ; Cut/paste from clipboard
  (setq x-select-enable-primary t)             ; And from selection buffer
  (setq auto-revert-verbose nil)               ; Don't warn when file changes
  (setq vc-follow-symlinks t)                  ; Just do it
  (setq global-auto-revert-non-file-buffers t) ; For all buffer types
  (setq mouse-drag-copy-region t)              ; Drag stuff
  ;; (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))  ; Really slow mouse scroll
  (setq mouse-wheel-progressive-speed nil) ; Don't speed up
  (setq scroll-step 1)                     ; Go slow
  (setq scroll-conservatively 10000)       ; Don't jump when scrolling
  (setq auto-window-vscroll nil)           ; Don't jump when scrolling
  (setq visible-bell t)                    ; Don't beep
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  (setq-default ispell-program-name "aspell")
  (setq-default save-place t)             ; Come back to the same place in buffer next visit
  (setq-default fill-column 80)

  ;; (show-paren-mode 1)                     ; Show matching parenthesis
  (global-hl-line-mode t)                 ; highlight line all the time
  (transient-mark-mode t)                 ; Allow highlighting
  (global-auto-revert-mode 1)             ; Change buffers if they change on disk
  (scroll-bar-mode -1)                    ; Turn off scroll
  (tool-bar-mode -1)                      ; Turn off tool-bar
  (when window-system (menu-bar-mode 1)); Still show the menubar
  ;; (delete-selection-mode 1)               ; Selection is deleted
  (semantic-mode 1)                       ; Use cedet


  (defalias 'yes-or-no-p 'y-or-n-p)       ; y

  ;; Open init file with C-x r j e
  (set-register ?e (cons 'file "~/.emacs.d/settings.org"))
  (set-register ?o (cons 'file "~/Nextcloud/org/notes.org"))
#+end_src

* Functions

#+begin_src emacs-lisp :tangle yes
  (defun toggle-window-split()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

  ;; Rotate windows because you opened it in the wrong one
  (defun rotate-windows ()
    "Rotate your windows"
    (interactive)
    (cond ((not (> (count-windows)1))
           (message "You can't rotate a single window!"))
          (t
           (setq i 1)
           (setq numWindows (count-windows))
           (while (< i numWindows)
             (let* (
                    (w1 (elt (window-list) i))
                    (w2 (elt (window-list) (+ (% i numWindows) 1)))

                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))

                    (s1 (window-start w1))
                    (s2 (window-start w2))
                    )
               (set-window-buffer w1 b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i (1+ i)))))))


  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content of a buffer.
          Does not indent buffer, because it is used for a before-save-hook, and that
          might be bad."
    (interactive)
    (unless (derived-mode-p 'makefile-mode)
      (untabify (point-min) (point-max))
      (delete-trailing-whitespace)
      (set-buffer-file-coding-system 'utf-8)))

  ;; Various superfluous white-space. Just say no.
  (add-hook 'before-save-hook 'cleanup-buffer-safe)

  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer.
          Including indent-buffer, which should not be called automatically on save."
    (interactive)
    (cleanup-buffer-safe)
    (indent-region (point-min) (point-max)))

  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))

  (defun open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  (defun open-line-above ()
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines 1))
      (forward-line)
      (move-to-column col)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines -1))
      (move-to-column col)))

  (defun comint-delchar-or-eof-or-kill-buffer (arg)
    (interactive "p")
    (if (null (get-buffer-process (current-buffer)))
        (kill-buffer)
      (comint-delchar-or-maybe-eof arg)))

  (add-hook 'shell-mode-hook
            (lambda ()
              (define-key shell-mode-map
                (kbd "C-d") 'comint-delchar-or-eof-or-kill-buffer)))

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (linum-mode 1)
          (goto-line (read-number "Goto line: ")))
      (linum-mode -1)))

                                          ; if you're windened, narrow to the region, if you're narrowed, widen
                                          ; bound to C-x n
  (defun narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
          Intelligently means: region, org-src-block, org-subtree, or defun,
          whichever applies first.
          Narrowing to org-src-block actually calls `org-edit-src-code'.

          With prefix P, don't widen, just narrow even if buffer is already
          narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  (defun beginning-of-line-dwim ()
    "Toggle between moving point to the first non-whitespace character, and the start of the line."
    (interactive)
    (let ((start-position (point)))
      ;; Move to the first non-whitespace character.
      (back-to-indentation)

      ;; If we haven't moved position, go to start of the line.
      (when (= (point) start-position)
        (move-beginning-of-line nil))))




  (defun client-save-kill-emacs(&optional display)
    " This is a function that can bu used to shutdown save buffers and
      shutdown the emacs daemon. It should be called using
      emacsclient -e '(client-save-kill-emacs)'.  This function will
      check to see if there are any modified buffers or active clients
      or frame.  If so an x window will be opened and the user will
      be prompted."

    (let (new-frame modified-buffers active-clients-or-frames)

                                          ; Check if there are modified buffers or active clients or frames.
      (setq modified-buffers (modified-buffers-exist))
      (setq active-clients-or-frames ( or (> (length server-clients) 1)
                                          (> (length (frame-list)) 1)
                                          ))

                                          ; Create a new frame if prompts are needed.
      (when (or modified-buffers active-clients-or-frames)
        (when (not (eq window-system 'x))
          (message "Initializing x windows system.")
          (x-initialize-window-system))
        (when (not display) (setq display (getenv "DISPLAY")))
        (message "Opening frame on display: %s" display)
        (select-frame (make-frame-on-display display '((window-system . x)))))

                                          ; Save the current frame.
      (setq new-frame (selected-frame))


                                          ; When displaying the number of clients and frames:
                                          ; subtract 1 from the clients for this client.
                                          ; subtract 2 from the frames this frame (that we just created) and the default frame.
      (when ( or (not active-clients-or-frames)
                 (yes-or-no-p (format "There are currently %d clients and %d frames. Exit anyway?" (- (length server-clients) 1) (- (length (frame-list)) 2))))

                                          ; If the user quits during the save dialog then don't exit emacs.
                                          ; Still close the terminal though.
        (let((inhibit-quit t))
                                          ; Save buffers
          (with-local-quit
            (save-some-buffers))

          (if quit-flag
              (setq quit-flag nil)
                                          ; Kill all remaining clients
            (progn
              (dolist (client server-clients)
                (server-delete-client client))
                                          ; Exit emacs
              (kill-emacs)))
          ))

                                          ; If we made a frame then kill it.
      (when (or modified-buffers active-clients-or-frames) (delete-frame new-frame))
      )
    )


  (defun modified-buffers-exist()
    "This function will check to see if there are any buffers
      that have been modified.  It will return true if there are
      and nil otherwise. Buffers that have buffer-offer-save set to
      nil are ignored."
    (let (modified-found)
      (dolist (buffer (buffer-list))
        (when (and (buffer-live-p buffer)
                   (buffer-modified-p buffer)
                   (not (buffer-base-buffer buffer))
                   (or
                    (buffer-file-name buffer)
                    (progn
                      (set-buffer buffer)
                      (and buffer-offer-save (> (buffer-size) 0))))
                   )
          (setq modified-found t)
          )
        )
      modified-found
      )
    )
#+end_src

* More settings
#+begin_src emacs-lisp :tangle no


  ;; Stop doing bad things
  (put 'overwrite-mode 'disabled t)

  (add-hook 'before-save-hook
            (lambda ()
              (when buffer-file-name
                (let ((dir (file-name-directory buffer-file-name)))
                  (when (and (not (file-exists-p dir))
                           (y-or-n-p (format "Directory %s does not exist. Create it? " dir)))
                    (make-directory dir t))))))

  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (dolist (hook '(text-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1))))
  (dolist (hook '(prog-mode-hook))
    (add-hook hook (lambda () (flyspell-prog-mode 1))))



  (recentf-mode 1)
  (setq recentf-max-saved-items 50)
  (add-to-list 'recentf-exclude "/\\.git/.*\\")         ; ignore git contents
  (add-to-list 'recentf-exclude ".*/elpa/.*\\")           ; package files
  (add-to-list 'recentf-exclude "/el-get/.*\\")           ; package files
  (add-to-list 'recentf-exclude "/auto-save-list/.*\\")   ; auto-save junk
  (add-to-list 'recentf-exclude "TAGS")
  (add-to-list 'recentf-exclude ".*-autoloads\\.el\\'")
  (add-to-list 'recentf-exclude ".*\\.gz\\'")
  (add-to-list 'recentf-exclude "ido.last")
  (add-to-list 'recentf-exclude "session\\.[a-f0-9]*$")
  (add-to-list 'recentf-exclude "\\.aux$")
  (add-to-list 'recentf-exclude "/COMMIT_EDITMSG$")
  (add-to-list 'recentf-exclude no-littering-var-directory)
  (add-to-list 'recentf-exclude no-littering-etc-directory)
  (recentf-cleanup)

  (setq completion-ignored-extensions
        '(".o" ".elc" "~" ".bin" ".class" ".exe" ".ps" ".abs" ".mx"
          ".~jv" ".rbc" ".pyc" ".beam" ".aux" ".out" ".pdf" ".hbc"))

  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                             ("marmalade" . "http://marmalade-repo.org/packages/")
                             ("melpa" . "http://melpa.milkbox.net/packages/")
                             ("melpa-stable" . "https://stable.melpa.org/packages/")
                             ("elpy" . "https://jorgenschaefer.github.io/packages/")))
  ;; (package-refresh-contents)

  (add-to-list 'auto-mode-alist '("\\.*rc$" . conf-unix-mode))
#+end_src

* Global key bindings

#+begin_src emacs-lisp :tangle yes

  ;; Stop doing bad things
  (define-key global-map [(insert)] nil)
  (define-key global-map [(control insert)] 'overwrite-mode)
  (put 'overwrite-mode 'disabled t)
  (global-unset-key (kbd "C-z"))
  (global-unset-key (kbd "<prior>"))
  (global-unset-key (kbd "<next>"))


  (global-set-key (kbd "C-x C-l") (lambda () (interactive) (load-file user-init-file)))
  ;; (global-set-key (kbd "C-x C-r") 'recentf-open-files)  ; use helm-recentf
  (global-set-key (kbd "C-x C-b") 'ibuffer-other-window)
  (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
  (global-set-key (kbd "<f5>") 'revert-buffer)
  (global-set-key (kbd "C-x 5") 'toggle-window-split)
  (global-set-key (kbd "C-x 6") 'rotate-windows)
  (global-set-key (kbd "C-x 7") 'delete-frame)
  (global-set-key (kbd "<C-S-down>") 'move-line-down)
  (global-set-key (kbd "<C-S-up>") 'move-line-up)
  (global-set-key (kbd "<C-return>") 'open-line-below)
  (global-set-key (kbd "<C-S-return>") 'open-line-above)
  (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
  (global-set-key (kbd "C-c n") 'cleanup-buffer)
  (global-set-key "\M-l" 'goto-line)
  (global-set-key [remap goto-line] 'goto-line-with-feedback)
  (global-set-key (kbd "C-a") 'beginning-of-line-dwim)
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)


  (define-prefix-command 'spm-map)
  (global-set-key (kbd "C-c s") 'spm-map)
  (define-key spm-map (kbd "m") 'mu4e)
#+end_src

* Packages
#+begin_src emacs-lisp :tangle yes
  (use-package no-littering
    :ensure t
    :config)

  (use-package beacon                     ; Flash the line when point moves
    :ensure t
    :config
    (beacon-mode 1)
    (setq beacon-blink-delay 0.2)
    (setq beacon-color "red"))

  (use-package academic-phrases
    :ensure t)

  (use-package lua-mode
    :ensure t
    :mode ("\\.lua\\'" . lua-mode))

  (use-package async
    :ensure t
    :init (dired-async-mode 1))

  (use-package pretty-mode
    :ensure t
    :if window-system
    :config
    (global-pretty-mode t))

  (use-package yasnippet
    :defer 10
    :ensure t
    :init
    (yas-global-mode)
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all))

  (use-package free-keys
    :ensure t
    :bind ("C-h C-k" . free-keys))

  (use-package multi-term
    :ensure t
    :config
    (setq multi-term-program "/bin/bash"))

  (use-package magit
    :ensure t
    :defer t
    :bind ("C-x g" . magit-status))

  (use-package which-key
    :config
    (which-key-mode t)
    :ensure t)

                                          ; deletes all the whitespace when you hit backspace or delete
  (use-package hungry-delete
    :ensure t
    :config
    (global-hungry-delete-mode))

  (use-package expand-region
    :ensure t
    :bind
    ("C-=" . er/expand-region))

                                          ; mark and edit all copies of the marked region simultaniously.
  (use-package iedit
    :defer t
    :ensure t)


  (use-package ace-jump-mode
    :ensure t
    :bind
    ("C-." . ace-jump-mode))

  (use-package smartparens
    :ensure t
    :config
    (use-package smartparens-config)
    ;; (use-package smartparens-html)
    ;; (use-package smartparens-python)
    ;; (use-package smartparens-latex)
    (smartparens-global-mode t)
    (show-smartparens-global-mode t)

    :bind
    (("C-M-d" . sp-down-sexp)
     ("C-M-e" . sp-up-sexp)
     ("C-M-a" . sp-backward-down-sexp)
     ("C-M-u" . sp-backward-up-sexp)
     ("C-S-d" . sp-beginning-of-sexp)
     ("C-S-a" . sp-end-of-sexp)
     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)
     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)
     ("M-F" . sp-forward-symbol)
     ("M-B" . sp-backward-symbol)
     ("C-)" . sp-forward-slurp-sexp)
     ("C-}" . sp-forward-barf-sexp)
     ("C-(" . sp-backward-slurp-sexp)
     ("C-{" . sp-backward-barf-sexp)
     ("M-[" . sp-backward-unwrap-sexp)
     ("M-]" . sp-unwrap-sexp))
    :hook
    ((prog-mode markdown-mode) . turn-on-smartparens-strict-mode))

  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

  (use-package simple-mpc
    :ensure t)


  (use-package visual-regexp
    :ensure t
    :bind
    ("M-%" . vr/query-replace))

  (use-package smex
    :disabled t                           ; Use Counsel or helm M-x
    :ensure t
    :init
    (smex-initialize)
    :bind
    ("M-x" . smex)
    ("M-X" . smex-major-mode-commands)
    ("C-c C-c M-x" . execute-extended-command))

  (use-package window-number
    :ensure t
    :config
    (window-number-mode 1)
    (window-number-meta-mode 1))

  (use-package comint
    :config
    (setq ansi-color-for-comint-mode 'filter)
    (setq comint-scroll-to-bottom-on-input t)
    (setq comint-scroll-to-bottom-on-output t)
    (setq comint-move-point-for-output t)
    :bind (:map comint-mode-map
                ("<up>" . comint-previous-matching-input-from-input)
                ("<down>" . comint-next-matching-input-from-input)
                ("M-p" . comint-previous-matching-input-from-input)
                ("M-n" . comint-next-matching-input-from-input)
                ("C-<up>" . comint-previous-matching-input-from-input)
                ("C-<down>" . comint-next-matching-input-from-input)))

  (use-package saveplace
    :config
    ;; (setq save-place-file "~/.emacs.d/places")
    )

#+end_src

* Music

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package emms
    :ensure t
    :config
    (require 'emms-setup)
    (require 'emms-player-mpd)
    (emms-all)
    (setq emms-player-mpd-server-name "localhost")
    (setq emms-playr-mpd-server-port "6600")
    (add-to-list 'emms-player-list 'emms-player-mpd)
    (add-to-list 'emms-info-functions 'emms-info-mpd))

#+END_SRC
* Mail
#+begin_src emacs-lisp :tangle yes
  (use-package mu4e
    ;; :defer 5
    :config
    (setq message-kill-buffer-on-exit t)
    (setq mail-envelope-from (quote header))
    (setq mail-specify-envelope-from t)
    (setq message-sendmail-envelope-from (quote header))
    (setq send-mail-function (quote sendmail-send-it))
    (setq mu4e-get-mail-command "offlineimap -o")
    ;; use 'fancy' non-ascii characters in various places in mu4e
    (setq mu4e-use-fancy-chars t)

    ;; save attachment to my desktop (this can also be a function)
    (setq mu4e-attachment-dir "~/Downloads")

    ;; attempt to show images when viewing messages
    ;; (setq mu4e-html2text-command "html2text -utf8 -nobs -width 72")

    ;; (setq mu4e-html2text-command "w3m -dump -T text/html")
    (setq mu4e-view-prefer-html t)
    (setq shr-color-visible-luminance-min 80)
    (setq mu4e-view-show-images t)

    (setq mu4e-headers-date-format "%d-%m-%Y %H:%M")

    ;; enable inline images
    (setq mu4e-view-show-images t)
    ;; use imagemagick, if available
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))
    (setq mu4e-context-policy 'pick-first)
    ;; Don't ask to quit... why is this the default?
    (setq mu4e-confirm-quit nil)
    (setq mu4e-maildir "~/.mail")
    (setq mu4e-contexts
     `( ,(make-mu4e-context
       :name "UC-mail"
       :enter-func (lambda () (mu4e-message "Entering UC-mail context"))
           :leave-func (lambda () (mu4e-message "Leaving UC-mail context"))
       ;; we match based on the contact-fields of the message
       :match-func (lambda (msg)
             (when msg
               (mu4e-message-contact-field-matches msg
                 :to "shaun.mucalo@canterbury.ac.nz")))
       :vars '( ( user-mail-address      . "shaun.mucalo@canterbury.ac.nz"  )
                ( mu4e-sent-folder       . "/UC_mail/Sent Items")
                ( mu4e-drafts-folder     . "/UC_mail/Drafts")
                ( mu4e-trash-folder      . "/UC_mail/Deleted Items")
                ( user-full-name         . "Shaun Mucalo" )
                ( mu4e-maildir-shortcuts . ( ("/UC_mail/INBOX"        . ?i)
                                             ("/UC_mail/Sent Items"   . ?s)
                                             ("/UC_mail/Deleted Items". ?t)
                                             ("/UC_mail/Drafts"       . ?d)))
                ( mu4e-compose-signature .
                                         (concat
                                          "Shaun Mucalo\n"
                                          "University of Canterbury, New Zealand\n"))))
        ,(make-mu4e-context
       :name "gmail"
       :enter-func (lambda () (mu4e-message "Switch to the gmail context"))
       ;; no leave-func
       ;; we match based on the contact-fields of the message
       :match-func (lambda (msg)
             (when msg
               (mu4e-message-contact-field-matches msg
                 :to "shaunmucalo@gmail.com")))
       :vars '( ( user-mail-address       . "shaunmucalo@gmail.com" )
                ( user-full-name          . "Shaun Mucalo" )
                ( mu4e-compose-signature  .
                                          (concat
                                           "Shaun Mucalo\n"
                                           "Christchurch, New Zealand\n"))
                ( mu4e-sent-folder        . "/gmail_mail/Sent" )
                ( mu4e-trash-folder       . "/gmail_mail/Trash" )
                ( mu4e-drafts-folder      . "/gmail_mail/Drafts" )
                (mu4e-maildir-shortcuts   . ( ("/gmail_mail/INBOX"  . ?i)
                                              ("/gmail_mail/Sent"   . ?s)
                                              ("/gmail_mail/Trash"  . ?t)
                                              ("/gmail_mail/Drafts" . ?d)))))
        ,(make-mu4e-context
       :name "yahoo"
       :enter-func (lambda () (mu4e-message "Switch to the yahoo context"))
       ;; no leave-func
       ;; we match based on the maildir of the message; assume all
       ;; cycling-related messages go into the /cycling maildir
       :match-func (lambda (msg)
             (when msg
               (mu4e-message-field msg :maildir) "/yahoo"))
       :vars '( ( user-mail-address   . "s_mucalo@yahoo.co.nz" )
                ( user-full-name      . "Shaun Mucalo" )
                ( mu4e-sent-folder    . "/yahoo_mail/Sent" )
                ( mu4e-drafts-folder  . "/yahoo_mail/Drafts" )
                ( mu4e-trash-folder   . "/yahoo_mail/Trash" )
                ( mu4e-maildir-shortcuts . ( ("/yahoo_mail/Inbox"  . ?i)
                                             ("/yahoo_mail/Sent"   . ?s)
                                             ("/yahoo_mail/Trash"  . ?t)))
                ( mu4e-compose-signature  . nil)))))
    (setq mu4e-user-mail-address-list
     (delq nil
           (mapcar (lambda (context)
                     (when (mu4e-context-vars context)
                       (cdr (assq 'user-mail-address (mu4e-context-vars context)))))
                   mu4e-contexts))))

  (require 'gnus-dired)
  ;; make the `gnus-dired-mail-buffers' function also work on
  ;; message-mode derived modes, such as mu4e-compose-mode
  (defun gnus-dired-mail-buffers ()
    "Return a list of active message buffers."
    (let (buffers)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
          (set-buffer buffer)
          (when (and (derived-mode-p 'message-mode)
                     (null message-sent-message-via))
            (push (buffer-name buffer) buffers))))
      (nreverse buffers)))

  (setq gnus-dired-mail-mode 'mu4e-user-agent)
  (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)


  ;; Allow org-mode stuff in mu4e
  (use-package org-mu4e
    :after mu4e)
  (use-package mu4e-alert
    :disabled t
    :ensure t
    :config
    (mu4e-alert-set-default-style 'libnotify)
    (add-hook 'after-init-hook #'mu4e-alert-enable-notifications))

#+end_src

* Python
#+begin_src emacs-lisp :tangle yes
  (use-package python
    :defer t
    :mode ("\\.py\\'" . python-mode)
    :init
    (setq indent-tabs-mode nil)
    (setq default-tab-width 4)
    (setq python-shell-interpreter "ipython3"
          python-shell-interpreter-args "--simple-prompt -i")
    (setq python-shell-prompt-detect-failure-warning nil))

  ;;  py-electric-colon-active t
  ;;  py-smart-indentation t)


  (use-package cython-mode
    :defer t
    :ensure t
    :mode (("\\.pyx\\'"  . cython-mode)
           ("\\.spyx\\'" . cython-mode)
           ("\\.pxd\\'"  . cython-mode)
           ("\\.pxi\\'"  . cython-mode)))

  ;; # Either of these
  ;; pip install rope
  ;; pip install jedi
  ;; # flake8 for code checks
  ;; pip install flake8
  ;; # and autopep8 for automatic PEP8 formatting
  ;; pip install autopep8
  ;; # and yapf for code formatting
  ;; pip install yapf
  (use-package elpy
    :defer t
    :ensure t
    ;; :init (with-eval-after-load 'python (elpy-enable))
    :after python
    :init
    (elpy-enable)
    :config
    (setq elpy-rpc-backend "jedi"))

  (setq gud-pdb-command-name "python -m pdb")

#+end_src

* R

#+begin_src emacs-lisp :tangle yes
  (defun my-ess-start-R ()
    (interactive)
    (if (not (member "*R*" (mapcar (function buffer-name) (buffer-list))))
        (progn
          (delete-other-windows)
          (setq w1 (selected-window))
          (setq w1name (buffer-name))
          (setq w2 (split-window w1 nil t))
          (R)
          (set-window-buffer w2 "*R*")
          (set-window-buffer w1 w1name))))
  (defun my-ess-eval ()
    (interactive)
    (my-ess-start-R)
    (if (and transient-mark-mode mark-active)
        (call-interactively 'ess-eval-region)
      (call-interactively 'ess-eval-line-and-step)))
  (add-hook 'ess-mode-hook
            '(lambda()
               (local-set-key [(shift return)] 'my-ess-eval)))
  (add-hook 'inferior-ess-mode-hook
            '(lambda()
               (local-set-key [C-up] 'comint-previous-input)
               (local-set-key [C-down] 'comint-next-input)))
  (add-hook 'Rnw-mode-hook
            '(lambda()
               (local-set-key [(shift return)] 'my-ess-eval)))

  ;; (use-package ess-site
  ;;   :defer t)

  (use-package ess
    :defer t
    :ensure t
    :init (use-package ess-site)
    :bind (:map ess-mode-map
                ([(shift return)] . my-ess-eval))
    :config
    (setq ess-local-process-name "R")
    (setq ess-ask-for-ess-directory nil))
#+end_src

* c
#+begin_src emacs-lisp :tangle yes
    (use-package cc-mode
      :config
      (setq c-default-style "ellemtel")
      (setq c-basic-offset 4)
      ;; (setq c-toggle-hungry-state)
      )

    (use-package flycheck
      :ensure t
      :config
      (global-flycheck-mode t)
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))


  (use-package dumb-jump
    :defer t
    :bind (("M-g o" . dumb-jump-go-other-window)
           ("M-g j" . dumb-jump-go)
           ("M-g i" . dumb-jump-go-prompt)
           ("M-g x" . dumb-jump-go-prefer-external)
           ("M-g z" . dumb-jump-go-prefer-external-other-window))
    :config (setq dumb-jump-selector 'helm) ;; (setq dumb-jump-selector 'ivy)
    :ensure)

#+end_src

* Theme

#+begin_src emacs-lisp :tangle yes
  (use-package monokai-theme
    :disabled t
    :ensure t)

  (use-package grandshell-theme
    :disabled t
    :ensure t)

  (use-package cyberpunk-theme
    :ensure t)

  (use-package xresources-theme
    :disabled t
    :ensure t
    :if window-system
    :init
    (if (daemonp)
        (add-hook 'after-make-frame-functions
                  '(lambda (f)
                     (with-selected-frame f
                       (when (window-system f) (load-theme 'xresources)))))
      (load-theme 'xresources)))


  (use-package smart-mode-line
    :disabled t
    :ensure t
    :config

    (use-package smart-mode-line-powerline-theme
      :ensure t
      :config
      (sml/setup)
      (sml/apply-theme 'powerline)))


#+end_src

* Dired
#+begin_src emacs-lisp :tangle yes
    ;; Go to first real file in dired M-<
    (defun dired-back-to-top ()
      (interactive)
      (beginning-of-buffer)
      (dired-next-line 3))

    (define-key dired-mode-map
      (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

    ;; Go to last real file in dired M->
    (defun dired-jump-to-bottom ()
      (interactive)
      (end-of-buffer)
      (dired-next-line -1))

    (define-key dired-mode-map
      (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)

    (use-package bookmark+
      :load-path "wiki-packages/bookmark-plus")

    (use-package dired+
      :load-path "wiki-packages/dired-plus/"
      :config
      (setq diredp-hide-details-initially-flag t))
#+end_src

* LaTeX
#+begin_src emacs-lisp :tangle yes
  (use-package latex
    :defer t
    :ensure auctex
    :mode ("\\.tex\\'" . latex-mode)
    :commands (latex-mode LaTeX-mode plain-tex-mode)
    :bind (:map LaTeX-mode-map
                ("C-c C-r" . reftex-query-replace-document)
                ("C-c C-g" . reftex-grep-document))
    :config
    :hook
    ((LaTeX-mode . LaTeX-math-mode)
     (LaTeX-mode . flyspell-mode)
     (LaTeX-mode . turn-on-reftex)
     (LaTeX-mode . TeX-source-correlate-mode)
     (text-mode . turn-on-auto-fill))
    :init
    (setq TeX-auto-save t
          TeX-save-query nil
          TeX-show-compilation t
          TeX-parse-self t
          TeX-source-correlate-start-server t
          TeX-save-query nil
          TeX-PDF-mode t
          TeX-error-overview-open-after-TeX-run t)
    (setq-default TeX-master nil))

  (use-package preview
    :commands LaTeX-preview-setup
    :init
    (progn
      (setq-default preview-scale 1.4
                    preview-scale-function '(lambda (* (/ 10.0 (preview-document-pt)) preview-scale)))))

  (use-package reftex
    :defer t
    :commands turn-on-reftex
    :init
    (progn
      (setq reftex-plug-into-AUCTeX t
            reftex-extra-bindings t)))

  (use-package bibtex
    :defer t
    :mode ("\\.bib" . bibtex-mode)
    :init
    (progn
      (setq bibtex-align-at-equal-sign t)
      (add-hook 'bibtex-mode-hook (lambda () (set-fill-column 120)))))


  (eval-after-load "tex"
    '(setq TeX-command-list
           (append TeX-command-list
                   (list
                    (list "XeLaTeX" "%`xelatex%(mode)%' %t"
                          'TeX-run-TeX nil t :help "Run XeLaTeX")
                    (list "Sage" "sage %s.sagetex.sage"
                          'TeX-run-command nil t :help "Run SAGE.")
                    (list "Wordcount" "texcount %t"
                          'TeX-run-shell nil t :help "Run texcount.")
                    (list "Pythontex"
                          "python /usr/share/texmf-dist/scripts/pythontex/pythontex.py %t"
                          'TeX-run-shell nil t :help "Run pythontex.")
                    (list "Depythontex"
                          "python /usr/share/texmf-dist/scripts/pythontex/depythontex.py %t"
                          'TeX-run-shell nil t :help "Run depythontex.")
                    (list "Latexmk" "latexmk -pdf %s"
                          'TeX-run-TeX nil t :help "Run Latexmk on file")))))

  (defun TeX-error-delete-window ()
    "Delete TeX error window when there are no errors to show."
    (let ((w (get-buffer-window))
          (b (get-buffer "*TeX Help*")))
      (when w
        (delete-window w))
      (when b
        (setq w (get-buffer-window b))
        (when w
          (delete-window w)))))

  (defun TeX-error-install-delete-window-hook ()
    "Install `TeX-error-delete-window' in buffer-local `kill-buffer-hook'."
    (add-hook 'kill-buffer-hook #'TeX-error-delete-window nil t))

  (add-hook 'TeX-error-overview-mode-hook #'TeX-error-install-delete-window-hook)



  (defcustom TeX-buf-close-at-warnings-only t
    "Close TeX buffer if there are only warnings."
    :group 'TeX-output
    :type 'boolean)

  (defun my-tex-close-TeX-buffer (_output)
    "Close compilation buffer if there are no errors.
  Hook this function into `TeX-after-compilation-finished-functions'."
    (let ((buf (TeX-active-buffer)))
      (when (buffer-live-p buf)
        (with-current-buffer buf
          (when (progn (TeX-parse-all-errors)
                       (or
                        (and TeX-buf-close-at-warnings-only
                             (null (cl-assoc 'error TeX-error-list)))
                        (null TeX-error-list)))
            (cl-loop for win in (window-list)
                     if (eq (window-buffer win) (current-buffer))
                     do (delete-window win)))))))

  (add-hook 'TeX-after-compilation-finished-functions #'my-tex-close-TeX-buffer)
#+end_src

* Org mode
#+begin_src emacs-lisp :tangle yes
  (use-package org
    :mode
    ("\\.org$" . org-mode)
    :init
    (add-hook 'org-mode-hook 'turn-on-auto-fill)
    (add-hook 'auto-save-hook 'org-save-all-org-buffers)
    :config
    (org-babel-do-load-languages 'org-babel-load-languages
                                          '((python     . t)
                                            (latex      . t)
                                            (emacs-lisp . t)
                                            (R          . t)))
    (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.4))
    (setq org-log-done t)
    (setq org-startup-indented t)
    (setq org-agenda-files (list  "~/Nextcloud/org/"))
    (setq org-directory "~/Nextcloud/org")
    (setq org-default-notes-file (concat org-directory "/unfiled.org"))
    (setq org-refile-targets '((org-agenda-files :maxlevel . 1)))
    (setq org-refile-allow-creating-parent-nodes 'confirm)
    (setq org-refile-use-outline-path 'file)
    (setq org-outline-path-complete-in-steps nil)
    (setq org-archive-location "::* Archived Tasks")
    (setq org-export-html-preamble nil)
    (setq org-hide-leading-stars t)
    (setq org-startup-folded (quote fold))
    (setq org-startup-indented t)
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-cycle-separator-lines 1)
    :bind
    ("C-c l" . org-store-link)
    ("C-c a" . org-agenda)
    ("C-c c" . org-capture)
    ("C-c b" . org-switchb))

  (use-package org-bullets
    :ensure t
    :hook
    (org-mode . (lambda() (org-bullets-mode 1))))

  (use-package ox-pandoc
    :ensure t)
#+end_src

** Org Agenda
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Default agenda preferences

  (setq org-deadline-warning-days 5)
  (setq org-agenda-timegrid-use-ampm t)
  (setq org-agenda-span 14)

  ;; Set max level to 9
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 9))

  ;; Include currently clocked task
  (setq org-clock-report-include-clocking-task t)
  ;; Show agenda in current window
  (setq org-agenda-window-setup 'current-window)


  ;; File specific agendas
  ;; Only works in the following configuration
  ;;
  ;; | Call       | Current    |
  ;; | from       | Org-mode   |
  ;; | this       | Agenda     |
  ;; | window     |            |
  ;; |------------+------------|
  ;; | Dired or other buffer   |
  ;; |                         |

  ;; notes.org agenda
  (global-set-key (kbd "C-c <f1>")
                  (lambda ()
                    (interactive)
                    (switch-to-buffer "notes.org")
                    (execute-kbd-macro (kbd "C-c a < a"))))

  ;; work.org agenda
  (global-set-key (kbd "C-c <f2>")
                  (lambda ()
                    (interactive)
                    (switch-to-buffer "work.org")
                    (execute-kbd-macro (kbd "C-c a < a"))))

  ;; home.org agenda
  (global-set-key (kbd "C-c <f3>")
                  (lambda ()
                    (interactive)
                    (switch-to-buffer "home.org")
                    (execute-kbd-macro (kbd "C-c a < a"))))

  ;; finance.org agenda
  (global-set-key (kbd "C-c <f4>")
                  (lambda ()
                    (interactive)
                    (switch-to-buffer "finance.org")
                    (execute-kbd-macro (kbd "C-c a < a"))))

  ;; hobbies.org agenda
  (global-set-key (kbd "C-c <f5>")
                  (lambda ()
                    (interactive)
                    (switch-to-buffer "hobbies.org")
                    (execute-kbd-macro (kbd "C-c a < a"))))
#+END_SRC

** Org Capture

#+BEGIN_SRC emacs-lisp :tangle yes

  (setq org-todo-keywords
    '((sequence "TODO(t)" "WAITING(w@/!)" "|" "DONE(d!)" "POSTPONED(p@/!)" "CANCELLED(c@)")))
    ;; Capture Templates for TODO tasks
    (setq org-capture-templates
          '(

       ;; Templates for the TASKS keyword sequence
       ("t" "Tasks")

       ;; TODO     (t) Todo template

       ("tt" "TODO      (t) Todo" entry (file "unfiled.org")
        "* TODO %?
      :PROPERTIES:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"TODO\"       from \"\"           %U
      :END:" :empty-lines 1)

       ;; WAITING  (w) Waiting template
       ("tw" "WAITING   (w) Waiting" entry (file "unfiled.org")
        "* WAITING %?
      :PROPERTIES:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"WAITING\"    from \"\"           %U
      :END:" :empty-lines 1)

       ;; CANCELLED(x) Cancelled template
       ("tx" "CANCELLED (x) Cancelled" entry (file "unfiled.org")
        "* CANCELLED %
      CLOSED: %U
      :PROPERTIES:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"TODO\"       from \"\"           %U
      :END:" :empty-lines 1)

       ;; DONE     (d) Done template
       ("td" "DONE      (d) Done" entry (file "unfiled.org")
        "* DONE %?
      CLOSED: %U
      :PROPERTIES:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"DONE\"       from \"\"           %U
      :END:" :empty-lines 1)

       ;; Templates for the POSSESSIONS keyword sequence
       ("p" "Possessions")

       ;; PURCHASE (p) Purchase template
       ("pp" "PURCHASE  (p) Purchase" entry (file "unfiled.org")
        "* PURCHASE %?
      :PROPERTIES:
      :Cost:
      :Paid:
      :Method:   [[finances:%^{Method|Cheque|Savings|Joint|Bills}][%\\1]]
      :Merchant: [[people:%^{Merchant}][%\\2]]
      :Link:
      :Quantity:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"PURCHASE\"   from \"\"           %U
      :END:")

       ;; PURCHASED(j) Purchased template
       ("pj" "PURCHASED (j) Purchased" entry (file "unfiled.org")
        "* PURCHASED %?
      :PROPERTIES:
      :Cost:
      :Paid:
      :Method:   [[finances:%^{Method|Cheque|Savings|Joint|Bills}][%\\1]]
      :Merchant: [[people:%^{Merchant}][%\\2]]
      :Link:
      :Quantity:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"PURCHASED\"  from \"\"           %U
      :END:" :empty-lines 1)

       ;; SELL     (k) Sell template
       ("pk" "SELL      (k) Sell" entry (file "unfiled.org")
        "* SELL %?
      :PROPERTIES:
      :Cost:
      :Paid:
      :Method:   [[finances:%^{Method|Cheque|Savings|Joint|Bills}][%\\1]]
      :Merchant: [[peo:%^{Merchant}][%\\2]]
      :Link:
      :Quantity:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"SELL\"       from \"\"           %U
      :END:" :empty-lines 1)

       ;; SOLD     (k) Sold template
       ("pc" "SOLD      (c) Sold" entry (file "unfiled.org")
        "* SOLD %?
      CLOSED: %U
      :PROPERTIES:
      :Cost:
      :Paid:
      :Method:   [[finances:%^{Method|Cheque|Savings|Joint|Bills}][%\\1]]
      :Merchant: [[peo:%^{Merchant}][%\\2]]
      :Merchant:
      :Link:
      :Quantity:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"SOLD\"       from \"\"           %U
      :END:" :empty-lines 1)

       ("n" "Non-TODO States")
       ;;          (n) Note template
       ("nn" "          (n) Note" entry (file "unfiled.org")
        "* %? :note:
      :PROPERTIES:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"\"           from \"\"           %U
      :END:" :empty-lines 1)

       ;;          (h) Heading template
       ("nh" "          (h) Heading" entry (file "unfiled.org")
        "* %?
      :PROPERTIES:
      :END:
      :LOGBOOK:
      - State \"\"           from \"\"           %U
      :END:" :empty-lines 1)

       ;;          (j) Journal template
       ("nj" "          (j) Journal" entry (file+headline "notes.org" "Journal")
        "* Journal :org:
      :PROPERTIES:
      :Via:
      :Note:
      :END:
      :LOGBOOK:
      - State \"\"           from \"\"           %U
      :END:
      %T\n\n  %?" :empty-lines 1)

       ;;          (s) Shopping template
       ("ns" "          (s) Shopping" entry (file "unfiled.org")
        "* %^{Action|Paid|Shopped at|Ate at|Drank at} %^{Place} :finance:
      :PROPERTIES:
      :Cost:     %^{Cost}
      :Paid:     %^{Paid}
      :Method:   [[finances:%^{Method|Cheque|Savings|Joint|Bills}][%\\5]]
      :Merchant: [[people:%\\2][%\\2]]
      :Link:     %?
      :Note:
      :END:
      :LOGBOOK:
      - State \"\"           from \"\"           %U
      :END:
      %T
      | Item                           | Price ($) | Amount    | Total ($) |
      |                                | <9>       | <9>       | <9>       |
      |--------------------------------+-----------+-----------+-----------|
      |                                |           |           |           |
      |                                |           |           |           |
      |--------------------------------+-----------+-----------+-----------|
      | Tax                            |           | 1         |           |
      | Total                          |           |           |           |
      ,#+TBLFM: $4=$2*$3;%.2f::@>$4=vsum(@3..@-1);%.2f
      " :empty-lines 1)
       ))

#+END_SRC

* Calendar
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-caldav
  :disabled t
  :init
  ;; This is the sync on close function; it also prompts for save after syncing so
  ;; no late changes get lost
  ;; (defun org-caldav-sync-at-close ()
  ;;   (org-caldav-sync)
  ;;   (save-some-buffers))

  ;; ;; This is the delayed sync function; it waits until emacs has been idle for
  ;; ;; "secs" seconds before syncing.  The delay is important because the caldav-sync
  ;; ;; can take five or ten seconds, which would be painful if it did that right at save.
  ;; ;; This way it just waits until you've been idle for a while to avoid disturbing
  ;; ;; the user.
  ;; (defvar org-caldav-sync-timer nil
  ;;   "Timer that `org-caldav-push-timer' used to reschedule itself, or nil.")
  ;; (defun org-caldav-sync-with-delay (secs)
  ;;   (when org-caldav-sync-timer
  ;;     (cancel-timer org-caldav-sync-timer))
  ;;   (setq org-caldav-sync-timer
  ;;         (run-with-idle-timer
  ;;          (* 1 secs) nil 'org-caldav-sync)))

  :ensure t
  :config
  (setq org-icalendar-alarm-time 1)
  ;; ;; This makes sure to-do items as a category can show up on the calendar
  ;; (setq org-icalendar-include-todo t)
  ;; ;; This ensures all org "deadlines" show up, and show up as due dates
  ;; (setq org-icalendar-use-deadline '(event-if-todo event-if-not-todo todo-due))
  ;; ;; This ensures "scheduled" org items show up, and show up as start times
  ;; (setq org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo))
  ;; ;; Add the delayed save hook with a five minute idle timer
  ;; (add-hook 'after-save-hook
  ;;           (lambda ()
  ;;             (when (eq major-mode 'org-mode)
  ;;               (org-caldav-sync-with-delay 300))))
  ;; ;; Add the close emacs hook
  ;; (add-hook 'kill-emacs-hook 'org-caldav-sync-at-close)
  (setq org-caldav-uuid-extension ".EML")
  (setq org-icalendar-timezone "New Zealand Standard Time")
  (setq org-caldav-calendars '((:calendar-id "Calendar"
                                             :files ("~/Nextcloud/org/work.org")
                                             :inbox "~/Nextcloud/org/calendar.org"
                                             :url "http://localhost:1080/users/shaun.mucalo@canterbury.ac.nz"))))


    ;; (use-package calfw
    ;;   :ensure t)

    ;; (use-package calfw-cal
    ;;   :ensure t)
    ;; (use-package calfw-org
    ;;   :ensure t)
    ;; (use-package calfw-ical
    ;;   :ensure t)

    ;; (defun my-open-calendar()
    ;;   (interactive)
    ;;   (cfw:open-calendar-buffer
    ;;    :contents-sources
    ;;    (list(cfw:ical-create-source ""))))
#+END_SRC

* exwm
#+begin_src emacs-lisp :tangle yes
    (use-package exwm
      :ensure t
      :if (string= (getenv "XDG_SESSION_DESKTOP") "exwm")
      :init
      (fringe-mode 1)
      (menu-bar-mode -1)
      (display-time-mode t)
      (server-start)
      (setq display-time-default-load-average nil)
      :hook
      (after-init . my-daemon-start)

      :config
      (setq exwm-workspace-number 4)
      (add-hook 'exwm-update-class-hook
                (lambda ()
                  (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                              (string= "gimp" exwm-instance-name))
                    (exwm-workspace-rename-buffer exwm-class-name))))
      (add-hook 'exwm-update-title-hook
                (lambda ()
                  (when (or (not exwm-instance-name)
                            (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                            (string= "gimp" exwm-instance-name))
                    (exwm-workspace-rename-buffer exwm-title))))

      ;; Global keybindings can be defined with `exwm-input-global-keys'.
      ;; Here are a few examples:
      (setq exwm-input-global-keys
            `(
              ;; Bind "s-r" to exit char-mode and fullscreen mode.
              ([?\s-r] . exwm-reset)
              ;; Bind "s-w" to switch workspace interactively.
              ([?\s-w] . exwm-workspace-switch)
              ;; Bind "s-0" to "s-9" to switch to a workspace by its index.
              ,@(mapcar (lambda (i)
                          `(,(kbd (format "s-%d" i)) .
                            (lambda ()
                              (interactive)
                              (exwm-workspace-switch-create ,i))))
                        (number-sequence 0 9))
              ;; Bind "s-&" to launch applications ('M-&' also works if the output
              ;; buffer does not bother you).
              ([?\s-&] . (lambda (command)
                           (interactive (list (read-shell-command "$ ")))
                           (start-process-shell-command command nil command)))
              ;; Bind "s-<f2>" to "slock", a simple X display locker.
              ([s-f2] . (lambda ()
                          (interactive)
                          (start-process "" nil "~/bin/lock")))))

      ;; To add a key binding only available in line-mode, simply define it in
      ;; `exwm-mode-map'.  The following example shortens 'C-c q' to 'C-q'.
      (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

      (setq exwm-input-simulation-keys
            '(
              ;; movement
              ([?\C-b] . [left])
              ([?\M-b] . [C-left])
              ([?\C-f] . [right])
              ([?\M-f] . [C-right])
              ([?\C-p] . [up])
              ([?\C-n] . [down])
              ([?\C-a] . [home])
              ([?\C-e] . [end])
              ([?\M-v] . [prior])
              ([?\C-v] . [next])
              ([?\C-d] . [delete])
              ([?\C-k] . [S-end delete])
              ;; cut/paste.
              ([?\C-w] . [?\C-x])
              ([?\M-w] . [?\C-c])
              ([?\C-y] . [?\C-v])
              ;; search
              ([?\C-s] . [?\C-f])))
      ;; You can hide the minibuffer and echo area when they're not used, by
      ;; uncommenting the following line.
                                            ; (setq exwm-workspace-minibuffer-position 'bottom)

      ;; You can hide the minibuffer and echo area when they're not used, by
      ;; uncommenting the following line
      ;; (setq exwm-workspace-minibuffer-position 'bottom)

      (use-package exwm-randr
        :init
        (setq exwm-randr-workspace-output-plist '(0 "DVI-I-1" 1 "DVI-I-2"))
        :config
        (exwm-randr-enable)
        :hook
        (exwm-randr-screen-change-hook . (lambda () (start-process-shell-command
                                                     "xrandr" nil "xrandr --output DVI-I-1 --output DVI-I-2 --auto"))))

      ;; (use-package exwm-config
      ;; :config
      ;; (exwm-config-ido))

      (use-package helm-exwm
        :ensure t
        )
      ;; Do not forget to enable EXWM. It will start by itself when things are ready.


      (defun my-daemon-start ()
        (make-process
         :name "unclutter"
         :buffer nil
         :command '("unclutter")
         :noquery t)
        (make-process
         :name "udiskie" :buffer nil
         :command '("udiskie --config=$HOME/.config/udiskie/config.yml") ; automount removable storage
         :noquery t)

        (make-process
         :name "polybar" :buffer nil
         :command '("~/bin/polybar_launch")
         :noquery t)

        ;; (make-process "" nil "dockd" "--daemon")
        (start-process-shell-command "" nil "~/bin/theme_set.sh -R")
        (start-process-shell-command "" nil "~/bin/mail-notify.py"))
      (exwm-enable)

      (defun my/volume-up ()
        (interactive)
        (start-process "" nil "pamixer" "--allow-boost" "-i" "5"))

      (defun my/volume-down ()
        (interactive)
        (start-process "" nil "pamixer" "--allow-boost" "-d" "5"))

      (defun my/mute ()
        (interactive)
        (start-process "" nil "pamixer" "--allow-boost" "-m"))
      (defun my/mpc-play ()
        (interactive)
        (start-process "" nil "mpc" "play"))
      (defun my/mpc-next ()
        (interactive)
        (start-process "" nil "mpc" "next"))
      (defun my/mpc-prev ()
        (interactive)
        (start-process "" nil "mpc" "prev")))


#+end_src

* Slime
#+begin_src emacs-lisp :tangle yes
    (defun slime-description-fontify ()
      "Fontify sections of SLIME Description."
      (with-current-buffer "*SLIME Description*"
        (highlight-regexp
         (concat "^Function:\\|"
                 "^Macro-function:\\|"
                 "^Its associated name.+?) is\\|"
                 "^The .+'s arguments are:\\|"
                 "^Function documentation:$\\|"
                 "^Its.+\\(is\\|are\\):\\|"
                 "^On.+it was compiled from:$")
         'hi-green-b)))

    (defadvice slime-show-description (after slime-description-fontify activate)
      "Fontify sections of SLIME Description."
      (slime-description-fontify))

  (setq inferior-lisp-program "clisp")

#+end_src

* Narrowing
Use one of the following
** Ivy/counsel/swiper
#+begin_src emacs-lisp :tangle yes
  (use-package counsel
    :disabled t
    :ensure t
    :bind
    (("M-y" . counsel-yank-pop)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))

  (use-package ivy
    :disabled t
    :ensure t
    :diminish (ivy-mode)
    :bind (("C-x b" . ivy-switch-buffer))
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "%d/%d ")
    (setq ivy-display-style 'fancy))

  (use-package swiper
    :disabled t
    :ensure t
    :bind (("C-s" . swiper)
           ("C-r" . swiper)
           ("C-c C-r" . ivy-resume)
           ("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file))
    :config
    (progn
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-display-style 'fancy)
      (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
      ))
#+end_src
** Helm

#+begin_src emacs-lisp :tangle yes

  (use-package helm
    :config
    (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
          helm-move-to-line-cycle-in-source     nil ; move to end or beginning of source when reaching top or bottom of source.
          helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
          helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
          helm-ff-file-name-history-use-recentf t
          helm-echo-input-in-header-line t)
    (setq helm-autoresize-max-height 0)
    (setq helm-autoresize-min-height 20)
    (setq helm-mode-fuzzy-match t)
    (setq helm-completion-in-region-fuzzy-match t)
    (setq helm-buffers-fuzzy-matching t)
    (setq helm-recentf-fuzzy-matching t)
    (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
    (helm-autoresize-mode 1)
    (helm-mode 1)
    :bind
    (("C-c h" . helm-command-prefix)
     ("C-x c" . nil)
     ("C-x C-f" . helm-find-files)
     ("M-x" . helm-M-x)
     ("C-." . helm-dabbrev)
     ("C-x b" . helm-mini)
     ;; ("C-x b" . helm-buffers-list)
     ("C-x C-r" . helm-recentf)
     ("M-y" . helm-show-kill-ring)
     :map helm-map
     ("<tab>" . helm-execute-persistent-action) ; rebind tab to run persistent action
     ("C-i" . helm-execute-persistent-action) ; make TAB work in terminal
     ("C-z" . helm-select-action)))

  ;; (use-package helm-config
  ;;  :after helm)
  (use-package projectile
    :config
    (projectile-global-mode)
    (setq projectile-completion-system 'helm)
    (helm-projectile-on))

  (use-package helm-projectile
    :after helm
    :ensure t)

  (use-package helm-ag
    :after helm
    :init
    (setq helm-follow-mode-persistent t)
    (setq helm-ag-insert-at-point 'symbol)
    :commands
    (helm-ag helm-projectile-ag)
    :bind
    ("M-p" . helm-projectile-ag))

  (use-package helm-descbinds
    :after helm
    :ensure t
    :bind ("C-h b" . helm-descbinds))

  (use-package helm-files)


  (use-package helm-swoop
    :after helm
    :ensure t
    :bind
    (("M-m" . helm-swoop)
     ("M-M" . helm-swoop-back-to-last-point))
    :init
    (bind-key "M-m" 'helm-swoop-from-isearch isearch-mode-map))

#+end_src
** Ido

#+begin_src emacs-lisp :tangle yes
  (use-package ido
    :disabled t
    :init (progn
            (ido-mode 1)
            ;; "~" adds the "/" automatically in find file, etc.
            (add-hook 'ido-setup-hook
                      (lambda ()
                        ;; Go straight home
                        (define-key ido-file-completion-map
                          (kbd "~")
                          (lambda ()
                            (interactive)
                            (if (looking-back "/")
                                (insert "~/")
                              (call-interactively 'self-insert-command)))))))

    :config
    (progn (setq ido-enable-prefix nil)
           (setq ido-enable-flex-matching t)
           (setq ido-create-new-buffer 'always)
           (setq ido-use-filename-at-point 'guess)
           (setq ido-max-prospects 10)))

  (use-package ido-vertical-mode
    :disabled t
    :init
    (ido-vertical-mode t)
    (setq ido-vertical-define-keys 'C-n-and-C-p-only)
    :ensure t)

#+end_src

* Auto-completion
** Auto-complete
#+begin_src emacs-lisp :tangle yes
  (use-package auto-complete
    :disabled t
    :ensure t
    :init
    (progn
      (ac-config-default)
      (global-auto-complete-mode t)))
#+end_src
** Company
#+begin_src emacs-lisp :tangle yes

  (use-package company
    :ensure t
    ;; :diminish ""
    :init
    ;; (add-hook 'prog-mode-hook 'company-mode)
    ;; (add-hook 'comint-mode-hook 'company-mode)
    :bind (:map company-active-map
                ("M-n" . nil)
                ("M-p" . nil)
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous)
                ("TAB" . company-complete-common-or-cycle)
                ("<tab>" . company-complete-common-or-cycle)
                ("S-TAB" . company-select-previous)
                ("<backtab>" . company-select-previous))
    :config
    (global-company-mode)
    (setq company-tooltip-limit 10)
    (setq company-idle-delay 0.2)
    (setq company-echo-delay 0)
    (setq company-minimum-prefix-length 3)
    (setq company-require-match nil)
    (setq company-selection-wrap-around t)
    (setq company-tooltip-align-annotations t)
    ;; (setq company-tooltip-flip-when-above t)
    (setq company-transformers '(company-sort-by-occurrence))) ; weight by frequency


  (defun company-yasnippet-or-completion ()
    "Solve company yasnippet conflicts."
    (interactive)
    (let ((yas-fallback-behavior
           (apply 'company-complete-common nil)))
      (yas-expand)))

  (add-hook 'company-mode-hook
   (lambda ()
     (substitute-key-definition
      'company-complete-common
      'company-yasnippet-or-completion
      company-active-map)))

  (use-package company-irony
    :ensure t
    :config
    (require 'company)
    (add-to-list 'company-backends 'company-irony))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hoom 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

  (use-package company-jedi
    :defer t
    :init
    (setq company-jedi-python-bin "python3")
    :config
    (add-to-list 'company-backends 'company-jedi))

  ;; (with-eval-after-load 'company
  ;;   (add-hook 'c++-mode-hook 'company-mode)
  ;;   (add-hook 'c-mode-hook 'company-mode))
#+end_src

* Debug
#+begin_src emacs-lisp :tangle yes
(use-package realgud
:disabled t
:ensure t
:defer t)

#+end_src

* Abbrev mode
#+begin_src emacs-lisp :tangle yes
  (use-package abbrev
    :diminish
    :hook
    ((text-mode prog-mode erc-mode LaTeX-mode) . abbrev-mode)
    (expand-load
     . (lambda ()
         (add-hook 'expand-expand-hook 'indent-according-to-mode)
         (add-hook 'expand-jump-hook 'indent-according-to-mode)))
    :config
    (if (file-exists-p abbrev-file-name)
        (quietly-read-abbrev-file)))
#+end_src

* Evil mode

#+begin_src emacs-lisp :tangle yes

  (use-package evil
    :disabled t
    :ensure t
    :init
    (setq evil-move-cursor-back nil)
    (setq evil-want-fine-undo t)
    (setq evil-move-beyond-eol t)
    :config
    (evil-mode 1)
    (use-package evil-leader
      :ensure t
      :config
      (global-evil-leader-mode)
      (evil-leader/set-leader "<SPC>"))


    (use-package evil-surround
      :ensure t
      :config (global-evil-surround-mode))

    (use-package evil-indent-textobject
      :ensure t)

    (use-package evil-mu4e
      :ensure t))

#+end_src
